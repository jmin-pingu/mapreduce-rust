use mr::ds::{TaskType, Intermediate};
use std::{
    thread,
    fs
};
use clap::Parser;
use std::{
    net::SocketAddr,
    time, 
};
use mr::rpc::TaskServiceClient;
use std::hash::{Hasher, Hash, DefaultHasher};
use tarpc::{
    client, 
    client::RpcError, 
    context, 
    tokio_serde::formats::Json
};

/// hash: Calculates the hash for a generic T that implements Hash
fn hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}

/// Description
///
/// Arguments
pub fn worker(
    id: i8, 
    mapf: &dyn Fn(String, String) -> String, 
    reducef: &dyn Fn(String, Vec<String>) -> String
) {
    // NOTE: RPC GetTask
    let s = "Hello".to_string();
    println!("{}", hash(&s) % 12);
    let delay = time::Duration::from_millis(250);

    println!("{:#?}", TaskType::Map);
    println!("{:#?}", TaskType::Reduce);
    println!("Worker {}", id);
    loop {
        println!("sleeping for 500 millis");
        thread::sleep(delay);
        do_map(mapf);
        do_reduce(reducef);
    }
    
}

#[derive(Parser)]
struct Flags {
    /// Sets the server address to connect to.
    #[clap(long)]
    server_addr: SocketAddr,
}

#[tokio::main]
pub async fn main() {
    let x: String = "Testing Response".to_string();
    let handle = thread::spawn(move ||
        send_echo(x)
    );
    println!("{:#?}", handle.join().unwrap());
}

// Define client-side RPC calls
#[tokio::main]
pub async fn send_echo(arg: String) -> Result<String, RpcError> {
    let flags = Flags::parse();
    let mut transport = tarpc::serde_transport::tcp::connect(flags.server_addr, Json::default);

    transport.config_mut().max_frame_length(usize::MAX);
    // TaskServiceClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
    // that takes a config and any Transport as input.
    let client: TaskServiceClient = TaskServiceClient::new(client::Config::default(), transport.await.unwrap()).spawn();

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    client.echo(context::current(), arg).await
}


#[tokio::main]
pub async fn send_get_task(id: i8, task_type: Option<TaskType>) -> Result<(Option<String>, bool), RpcError> {
    let flags = Flags::parse();
    let mut transport = tarpc::serde_transport::tcp::connect(flags.server_addr, Json::default);

    transport.config_mut().max_frame_length(usize::MAX);
    let client: TaskServiceClient = TaskServiceClient::new(client::Config::default(), transport.await.unwrap()).spawn();
    client.get_task(context::current(), id, task_type).await
}


#[tokio::main]
pub async fn send_completed_task(task: String) -> Result<bool, RpcError> {
    let flags = Flags::parse();
    let mut transport = tarpc::serde_transport::tcp::connect(flags.server_addr, Json::default);

    transport.config_mut().max_frame_length(usize::MAX);
    let client: TaskServiceClient = TaskServiceClient::new(client::Config::default(), transport.await.unwrap()).spawn();
    client.completed_task(context::current(), task).await
}

/// read_file: 
fn read_file(file_name: String) -> (String, String) {
    let contents = fs::read_to_string(file_name.clone()).expect("Should have been able to read file");
    (file_name, contents)

}

/// Description
///
/// Arguments
fn do_map(mapf: &dyn Fn(String, String) -> String) { }

/// Description
///
/// Arguments
fn do_reduce(reducef: &dyn Fn(String, Vec<String>) -> String) { }

