// NOTE: need a Coordinator and several workers. 
use std::hash::{Hasher, Hash, DefaultHasher};
use std::thread;
use std::time::{Duration, Instant};
use futures::prelude::*;
use crate::coordinator::Worker;
use tarpc::{
    client, context,
    server::{self, Channel},
};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let (client_transport, server_transport) = tarpc::transport::channel::unbounded();

    let server = server::BaseChannel::with_defaults(server_transport);
    tokio::spawn(
        server.execute(coordinator::Coordinator{taskman: ds::TaskManager::new()}.serve())
            // Handle all requests concurrently.
            .for_each(|response| async move {
                tokio::spawn(response);
            }));

    // WorkerClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
    // that takes a config and any Transport as input.
    let mut client: coordinator::WorkerClient = coordinator::WorkerClient::new(client::Config::default(), client_transport).spawn();

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    
    let bye: String = client.test(context::current(), "Whoops".to_string()).await?;

    let test = Instant::now();
    thread::sleep(Duration::from_millis(100));
    let s = "Hello".to_string();
    println!("{}", calculate_hash(&s) % 12);

    let task_man: ds::TaskManager = ds::TaskManager::new();
    println!("{:#?}", task_man);
    Ok(())
}

// Calculates the hash for a generic T that implements Hash
fn calculate_hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}

// Modules
pub mod ds;
pub mod rpc;
pub mod coordinator;
