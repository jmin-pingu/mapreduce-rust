use mr::ds::TaskType;
use std::thread;
use clap::Parser;
use std::{
    net::SocketAddr,
    collections::HashMap
};
use mr::rpc::TaskServiceClient;
use std::hash::{Hasher, Hash, DefaultHasher};
use tarpc::{
    client, 
    client::RpcError, 
    context, 
    tokio_serde::formats::Json
};
// NOTE: do not even need to sort if we use a HashMap of <String, Vec<String>>
pub struct Intermediate(HashMap<String, Vec<String>>);

impl Intermediate {
    pub fn new() -> Self {
        Intermediate(HashMap::new())
    }

    pub fn insert(&mut self, key: String, value: String) {
        if let Some(values) = self.0.get_mut(&key) {
            values.push(value);
        } else {
            self.0.insert(key, vec![value]);
        }
    }

    pub fn get(&mut self, key: String) -> Option<&Vec<String>> {
        self.0.get(&key) 
    }
}

// Calculates the hash for a generic T that implements Hash
fn calculate_hash<T: Hash>(t: &T) -> u64 {
    let mut s = DefaultHasher::new();
    t.hash(&mut s);
    s.finish()
}

/// Description
///
/// Arguments
pub fn worker() {
    // NOTE: RPC GetTask
    let s = "Hello".to_string();
    println!("{}", calculate_hash(&s) % 12);
    println!("{:#?}", TaskType::Map);
    println!("{:#?}", TaskType::Reduce);

}

#[derive(Parser)]
struct Flags {
    /// Sets the server address to connect to.
    #[clap(long)]
    server_addr: SocketAddr,
}

#[tokio::main]
pub async fn main() {
    let x: String = "Testing Response".to_string();
    let handle = thread::spawn(move ||
        send_echo(x)
    );
    println!("{:#?}", handle.join().unwrap());

}
#[tokio::main]
pub async fn send_echo(arg: String) -> Result<String, RpcError> {
    let flags = Flags::parse();
    let mut transport = tarpc::serde_transport::tcp::connect(flags.server_addr, Json::default);

    transport.config_mut().max_frame_length(usize::MAX);
    // WorkerClient is generated by the #[tarpc::service] attribute. It has a constructor `new`
    // that takes a config and any Transport as input.
    let client: TaskServiceClient = TaskServiceClient::new(client::Config::default(), transport.await.unwrap()).spawn();

    // The client has an RPC method for each RPC defined in the annotated trait. It takes the same
    // args as defined, with the addition of a Context, which is always the first arg. The Context
    // specifies a deadline and trace information which can be helpful in debugging requests.
    
    client.echo(context::current(), arg).await
}

/// Description
///
/// Arguments
fn do_map() { }

/// Description
///
/// Arguments
fn do_reduce() { }
