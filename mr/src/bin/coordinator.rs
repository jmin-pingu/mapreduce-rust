use mr::rpc::TaskService;
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use futures::{future, prelude::*};
use mr::ds::{TaskType, TaskManager};
use clap::Parser;
use std::net::{IpAddr, Ipv6Addr, SocketAddr};

#[derive(Clone)]
pub struct Coordinator {
    pub taskman: TaskManager, // NOTE: what if we have a daemon looping through the
                                          // task_manager looking for idle map jobs?
    socket_addr: SocketAddr
}
// This is the service definition. It looks a lot like a trait definition.

#[derive(Parser)]
struct Flags {
    /// Sets the port number to listen on.
    #[clap(long)]
    port: u16,
}

impl mr::rpc::TaskService for Coordinator {
    async fn get_task(mut self, _: context::Context, id: i8, task_type: Option<TaskType>) -> Option<String> {
        // crate::ds::Task::new("TimedTask".to_string(), 1, crate::ds::State::Idle, crate::ds::TaskType::Map)
        self.taskman.get_task(id, task_type)     
    }

    async fn completed_task(self, _: context::Context, task: String) -> bool { 
        // Change self.task_manager
        true 
    }    

    async fn echo(self, _: context::Context, input: String) -> String {
        format!("{input}")
    }
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

#[tokio::main]
pub async fn main() -> anyhow::Result<()> {
    let flags = Flags::parse();

    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), flags.port);
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    tracing::info!("Listening on port {}", listener.local_addr().port());
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated TaskService trait.
        .map(|channel| {
            let server = Coordinator{taskman: TaskManager::new(), socket_addr: channel.transport().peer_addr().unwrap()};
            channel.execute(server.serve()).for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}
