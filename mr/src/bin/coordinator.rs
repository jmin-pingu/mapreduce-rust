use mr::rpc::TaskService;
use tarpc::{
    context,
    server::{self, incoming::Incoming, Channel},
    tokio_serde::formats::Json,
};
use mr::worker::ReduceType;
use futures::{future, prelude::*};
use mr::ds::{
    task::{State, TaskType}, 
    taskman::TaskManager
};
use clap::Parser;
use std::net::{IpAddr, Ipv6Addr, SocketAddr};

#[derive(Clone)]
pub struct Coordinator {
    pub taskman: TaskManager, // NOTE: what if we have a daemon looping through the
                                          // task_manager looking for idle map jobs?
    socket_addr: SocketAddr
}
// This is the service definition. It looks a lot like a trait definition.

#[derive(Parser)]
struct Flags {
    /// Sets the port number to listen on.
    #[clap(long)]
    port: u16,
    #[clap(long)]
    path: String,
}

// NOTE: enumerate all the input files myself (i.e. give them unique monotonically increasing IDs)

impl mr::rpc::TaskService for Coordinator {
    async fn get_task(mut self, _: context::Context, id: i8, task_type: Option<TaskType>) -> Option<(Vec<String>, TaskType)> {
        let task_todo = self.taskman.get_idle_task(id, task_type);
        self.taskman.clean(); // Gets rid of completed tasks
        task_todo 
    }

    async fn completed_task(mut self, _: context::Context, task: String, reduce_type: ReduceType, nreduce: usize, nmap: usize, id: Option<i8>){ 
        self.taskman.task_completed(task, reduce_type, nreduce, nmap, id).unwrap()
    }    

    async fn echo(self, _: context::Context, input: String) -> String {
        format!("{input}")
    }
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

#[tokio::main]
pub async fn main() -> anyhow::Result<()> {
    let flags = Flags::parse();

    let server_addr = (IpAddr::V6(Ipv6Addr::LOCALHOST), flags.port);
    let mut listener = tarpc::serde_transport::tcp::listen(&server_addr, Json::default).await?;
    tracing::info!("Listening on port {}", listener.local_addr().port());
    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| future::ready(r.ok()))
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated TaskService trait.
        .map(|channel| {
            let server = Coordinator{taskman: TaskManager::new(), socket_addr: channel.transport().peer_addr().unwrap()};
            channel.execute(server.serve()).for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;
    Ok(())
}

/// aggregate_outputf: combine the completed outputf into one file
fn aggregate_outputf() { }
